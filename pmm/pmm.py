'''Functions needed for MD-PMM calculations'''

import MDAnalysis as mda
import numpy as np
import conversions as conv


def convert2Universe(geometry: np.ndarray) -> mda.Universe:
    '''Converts a geometry expressed as a numpy.ndarry to a mda.Universe
    object.

    Parameters:
        geometry (np.ndarray): (n_atoms, 4) matrix, containing atomic masses
            and xyz coordinates.
    Returns:
        univ_geom (mda.Universe): xyz coordinates of the systems and atom
            types.
    '''
    univ_geom = mda.Universe.empty(geometry.shape[0], trajectory=True)
    # print(univ_geom)
    # take the first element of each row (corresponding to the atomic masses)
    masses = [atom[0] for atom in geometry]
    univ_geom.add_TopologyAttr('mass', masses)
    # convert masses to atom type
    atom_types = [conv.mass2symbol[atom[0]] for atom in geometry]
    univ_geom.add_TopologyAttr('type', atom_types)
    # add xyz coordinates
    univ_geom.atoms.positions = geometry[:, 1:]
    # print(univ_geom.atoms.positions, univ_geom.atoms.masses)
    return univ_geom


def calc_el_field_pot(solv_coor: np.ndarray, charges: np.ndarray,
                      ref_origin: np.ndarray) -> tuple(np.ndarray, float):
    '''Calculate the electric field and potential due to the solvent
    considered as a distribution of point charges sampled by the simulation
    on a specified point (in the PMM: center of mass of the Quantum Center).

    Parameters:
        solv_coor (np.ndarray): (n_atoms, 3) array containing the xyz
            coordinates of the solvent.
        charges (np.ndarray): (n_atoms) array containing the force field
            charges of the solvent.
        ref_origin (np.ndarray): point on which the electric field is applied
            (in the PMM: center of mass the Quantum Center).

    Returns:
        el_field (np.ndarray): electric field expressed in its xyz components.
        potential (float): electric potential.
    '''
    xyz_distances = solv_coor - ref_origin
    # Fastest way to calculate norm of each row according to the answer of
    # Nico SchlÃ¶mer from:
    # https://stackoverflow.com/questions/7741878/how-to-apply-numpy-linalg-\
    # norm-to-each-row-of-a-matrix/45006970
    distances = np.sqrt(np.einsum('ij,ij->i', xyz_distances, xyz_distances))
    # TODO #2 check the sign of xyz_distances (it's the opposite in pmm.f90)
    el_field = (((charges * xyz_distances.T) / distances ** 3).T).sum(axis=0)
    potential = (charges / distances).sum()
    return el_field, potential


def pmm_matrix(energies: np.ndarray, rot_dip_matrix: np.ndarray,
               el_field: np.ndarray) -> np.ndarray:
    '''Construct PMM matrix.

    Parameters:
        energies (np.ndarray): energies of the electronic states (eigenvalues
            of the unperturbed Hamiltonian) expressed in Hartree (a.u.).
        rot_dip_matrix (np.ndarray): electric dipole matrix rotated in order
            to align the reference geometry to the geometry in the simulation
            trajectory frame. Values expressed in a.u..
        el_field (np.ndarray): electric field generated by the solvent
            considered as a distribution of point charges sampled by the
            simulation.

    Returns:
        pmm_matrix (np.ndarray): Hamiltonian matrix of the perturbed system
            as calculated
        '''
    # TODO #1 Add reference to PMM article.


if __name__ == '__main__':
    h2o = np.array([[16.0, 0,        0,       0],  # oxygen
                   [1.0, 0.95908, -0.02691, 0.03231],  # hydrogen
                   [1.0, -0.28004, -0.58767, 0.70556]])
    convert2Universe(h2o)
